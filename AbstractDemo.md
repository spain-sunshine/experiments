抽象是面向对象编程中的一个核心概念，它允许我们创建不能直接实例化的类，并为这些类定义一些没有具体实现的方法。这样，任何继承自这些抽象类的子类都必须提供这些方法的具体实现。
## 问题1：this
## 答案：
这段代码：
```
this.width = width;
this.height = height;
```
在Rectangle类的构造函数中，是用来初始化对象的width和height属性的。关键字this是一个引用，它指向当前对象。

当构造函数的参数名与类的属性名相同时，为了避免混淆，我们使用this关键字来指明我们是在引用对象的属性，而不是构造函数的参数。

在这个上下文中：

this.width 指的是 Rectangle 类的 width 属性。
width (没有 this.) 指的是传递给构造函数的参数。

如果你不写这两行代码，那么当你创建一个Rectangle对象时，width和height属性不会被初始化，它们的值会是默认值0.0（对于double类型的变量）。这可能会导致错误的行为，因为你可能期望这些属性有特定的初始值。

如果你选择不使用与属性名称相同的参数名称，那么你可以避免使用this。例如：
```
class Rectangle {
    private double width, height;

    public Rectangle(double w, double h) {
        width = w;
        height = h;
    }
}

```

在上面的代码中，由于参数名（w和h）与属性名（width和height）不同，因此不需要使用this关键字。但在实际编程中，为了代码的清晰性和可读性，很多开发者喜欢使用与属性名称相同的参数名称，并使用this来区分它们。

## 问题2. ：Circle circle = new Circle(5);换成Shape circle = new Circle(5);可以吗？有什么不同？

## 答案：
是的，你完全可以使用 Shape circle = new Circle(5);。当你这样做时，你是在使用多态的一个核心特点。

区别：

### 1.引用类型：

在 Circle circle = new Circle(5); 中，circle 是一个 Circle 类型的引用。
在 Shape circle = new Circle(5); 中，circle 是一个 Shape 类型的引用。

### 2.方法调用：

使用 Circle 类型的引用，你可以访问 Circle 类中定义的所有公共方法和属性，以及它从 Shape 继承的所有公共方法和属性。
使用 Shape 类型的引用，你只能访问 Shape 类中定义的所有公共方法和属性，即使实际对象是 Circle 类型。

### 3.转型：

如果你有一个 Shape 类型的引用，并且知道它实际上引用的是一个 Circle 对象，你可以将它转型为 Circle 类型：
```Shape shape = new Circle(5);
Circle circle = (Circle) shape;
```
转型之后，你可以使用 Circle 类中定义的所有方法和属性

### 总结：

使用 Shape circle = new Circle(5); 允许你编写更为通用的代码，因为你可以将引用设置为指向任何 Shape 的子类对象（例如，它也可以是一个 Rectangle）。这是多态的一个关键优势，它允许你编写可以操作各种形状的代码，而不必知道这些形状的具体类型。然而，如果你需要访问特定于 Circle 的方法或属性，你需要进行转型。

## 问题3. ：Shape circle = new Circle(5)；这样写有什么优势吗

## 答案：
使用 Shape circle = new Circle(5); 的方式有多种优势，主要体现在面向对象编程和多态的原则上。以下是一些优势：

代码的通用性：
通过使用超类（在这里是 Shape）的引用来持有子类（在这里是 Circle）的对象，你可以编写更通用的代码。例如，你可以有一个方法接受 Shape 类型的参数，并对其进行操作，而不用关心它实际上是哪种具体的形状。

灵活性：
如果你有一个方法接受 Shape 类型的参数，那么你可以传递任何 Shape 的子类对象给它，如 Circle、Rectangle 等。这意味着你可以轻松地添加更多的形状子类，而不必更改使用这些形状的代码。

解耦：
这种方法有助于将代码解耦。这意味着你的代码更少地依赖于具体的类，而更多地依赖于抽象。这使得代码更加模块化，易于维护和扩展。

隐藏实现细节：
你可以隐藏具体类的实现细节，只暴露它们共同的超类。这有助于降低错误的风险，因为其他代码不能直接访问和修改具体类的内部状态。

使用抽象类或接口作为引用类型的好处：它允许你编写更通用、更模块化、更易于维护和扩展的代码。

## 问题3. ：用抽象类(demo1)和接口(demo2)分别实现，差别是什么

## 答案：
1.实现与继承：

在抽象类版本中，Circle 和 Rectangle 是通过 extends 关键字继承 Shape。
在接口版本中，Circle 和 Rectangle 是通过 implements 关键字实现 IShape。

2.多继承与多实现：

Java 不支持多继承，所以一个类不能继承多个类。但它支持多实现，所以一个类可以实现多个接口。

3.状态与方法实现：

抽象类可以包含状态（即字段）和方法的实现（即非抽象方法），而接口在 Java 8 之前只能包含抽象方法的声明（在 Java 8 及之后，接口可以有默认方法和静态方法的实现）。

4.构造函数：

抽象类可以有构造函数，而接口不能。

5.
访问修饰符：

抽象类的方法可以有各种访问修饰符，而接口的方法默认为 public。

总的来说，选择抽象类还是接口取决于你的具体需求。如果你需要共享代码或状态（字段），抽象类可能是更好的选择。如果你需要为类提供一组公共方法，但不关心它们的实现，或者你想实现多重继承的效果，则接口可能更合适。